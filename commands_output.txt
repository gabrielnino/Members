

=== FILE: F:\LiveNetwork\Commands\ChatCommand.cs ===

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Services.Interfaces;
namespace Commands
{
public class ChatCommand : ICommand
{
private readonly ILogger<ChatCommand> _logger;
private readonly ILinkedInChat _iLinkedInChat;
public ChatCommand(ILogger<ChatCommand> logger, ILinkedInChat iLinkedInChat)
{
_logger = logger ?? throw new ArgumentNullException(nameof(logger));
_iLinkedInChat = iLinkedInChat ?? throw new ArgumentNullException(nameof(iLinkedInChat));
}
public async Task ExecuteAsync(Dictionary<string, string>? arguments = null)
{
_logger.LogInformation("ChatCommand: starting. args={@Args}", arguments);
await _iLinkedInChat.SendMessageAsync();
_logger.LogInformation("ChatCommand: finished.");
}
}
}

=== FILE: F:\LiveNetwork\Commands\CollectorCommand.cs ===

﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Services.Interfaces;
namespace Commands
{
public class CollectorCommand : ICommand
{
private readonly ILogger<CollectorCommand> _logger;
private readonly IConnectionInfoCollector _iConnectionInfoCollector;
public CollectorCommand(ILogger<CollectorCommand> logger, IConnectionInfoCollector iConnectionInfoCollector)
{
_logger = logger ?? throw new ArgumentNullException(nameof(logger));
_iConnectionInfoCollector = iConnectionInfoCollector ?? throw new ArgumentNullException(nameof(iConnectionInfoCollector));
}
public async Task ExecuteAsync(Dictionary<string, string>? arguments = null)
{
_logger.LogInformation("InviteCommand: starting. args={@Args}", arguments);
await _iConnectionInfoCollector.LoadConnectionsAsync();
_logger.LogInformation("InviteCommand: finished.");
}
}
}

=== FILE: F:\LiveNetwork\Commands\CommandArgs.cs ===

﻿namespace Commands
{
public class CommandArgs
{
public const string search = "--search";
public const string prompt = "--prompt";
public const string invite = "--invite";
public const string load = "--load";
public const string chat = "--chat";
private static readonly HashSet<string> ValidCommands = new(StringComparer.OrdinalIgnoreCase)
{
search,
prompt,
invite,
load,
chat
};
public string MainCommand { get; }
public Dictionary<string, string> Arguments { get; }
public CommandArgs(string[] args)
{
MainCommand = args.FirstOrDefault(IsCommand) ?? args.FirstOrDefault(IsArgument).Split("=").FirstOrDefault();
Arguments = args
.Where(IsArgument)
.Select(arg =>
{
var parts = arg.Split('=', 2);
var key = parts[0];
var value = parts.Length > 1 ? parts[1] : string.Empty;
return new KeyValuePair<string, string>(key, value);
})
.ToDictionary(kv => kv.Key, kv => kv.Value, StringComparer.OrdinalIgnoreCase);
}
private static bool IsCommand(string arg) => ValidCommands.Contains(arg);
private static bool IsArgument(string arg) => arg.Contains("=");
}
}

=== FILE: F:\LiveNetwork\Commands\CommandFactory.cs ===

﻿using Microsoft.Extensions.DependencyInjection;
using Services;
namespace Commands
{
public class CommandFactory
{
private readonly IServiceProvider _serviceProvider;
private readonly CommandArgs _jobCommandArgs;
public CommandFactory(IServiceProvider serviceProvider, CommandArgs jobCommandArgs)
{
_serviceProvider = serviceProvider;
_jobCommandArgs = jobCommandArgs;
}
public IEnumerable<ICommand> CreateCommand()
{
var commands = new List<ICommand>();
switch (_jobCommandArgs.MainCommand.ToLowerInvariant())
{
case CommandArgs.invite:
commands.Add(_serviceProvider.GetRequiredService<InviteCommand>());
break;
case CommandArgs.search:
commands.Add(_serviceProvider.GetRequiredService<SearchCommand>());
break;
case CommandArgs.prompt:
commands.Add(_serviceProvider.GetRequiredService<PromtCommand>());
break;
case CommandArgs.load:
commands.Add(_serviceProvider.GetRequiredService<CollectorCommand>());
break;
case CommandArgs.chat:
commands.Add(_serviceProvider.GetRequiredService<ChatCommand>());
break;
default:
commands.Add(_serviceProvider.GetRequiredService<HelpCommand>());
break;
}
return commands;
}
}
}

=== FILE: F:\LiveNetwork\Commands\HelpCommand.cs ===

﻿using Microsoft.Extensions.Logging;
namespace Commands
{
public class
HelpCommand : ICommand
{
private readonly ILogger<HelpCommand> _logger;
public HelpCommand(ILogger<HelpCommand> logger = null)
{
_logger = logger;
}
public Task ExecuteAsync(Dictionary<string, string>? Arguments)
{
_logger?.LogInformation("Displaying help information");
Console.WriteLine("Available commands:");
Console.WriteLine("--search\tSearch for jobs");
Console.WriteLine("--export\tExport results");
Console.WriteLine("--help\t\tShow this help");
return Task.CompletedTask;
}
}
}

=== FILE: F:\LiveNetwork\Commands\ICommand.cs ===

﻿namespace Commands
{
public interface ICommand
{
Task ExecuteAsync(Dictionary<string, string>? arguments=null);
}
}

=== FILE: F:\LiveNetwork\Commands\InviteCommand.cs ===

﻿using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Services.Interfaces;
namespace Commands
{
public class InviteCommand : ICommand
{
private readonly ILogger<InviteCommand> _logger;
private readonly IInviteConnections _iInviteCommand;
public InviteCommand(ILogger<InviteCommand> logger, IInviteConnections iInviteCommand)
{
_logger = logger ?? throw new ArgumentNullException(nameof(logger));
_iInviteCommand = iInviteCommand ?? throw new ArgumentNullException(nameof(iInviteCommand));
}
public async Task ExecuteAsync(Dictionary<string, string>? arguments = null)
{
_logger.LogInformation("InviteCommand: starting. args={@Args}", arguments);
await _iInviteCommand.Invite();
_logger.LogInformation("InviteCommand: finished.");
}
}
}

=== FILE: F:\LiveNetwork\Commands\PromtCommand.cs ===

﻿using Microsoft.Extensions.Logging;
using Services.Interfaces;
namespace Commands
{
public class PromtCommand(
ILogger<PromtCommand> logger,
IPromptGenerator promptGenerator) : ICommand
{
private readonly ILogger<PromtCommand> _logger = logger;
private readonly IPromptGenerator _promptGenerator = promptGenerator;
public async Task ExecuteAsync(Dictionary<string, string>? arguments = null)
{
_logger.LogInformation("Starting job application process...");
await _promptGenerator.GeneratPrompt();
}
}
}

=== FILE: F:\LiveNetwork\Commands\SearchCommand.cs ===

﻿using Microsoft.Extensions.Logging;
using Services.Interfaces;
namespace Commands
{
public class SearchCommand(
ISearchCoordinator linkedInService,
ILogger<SearchCommand> logger) : ICommand
{
private readonly ISearchCoordinator _linkedInService = linkedInService;
private readonly ILogger<SearchCommand> _logger = logger;
public async Task ExecuteAsync(Dictionary<string, string>? arguments = null)
{
_logger.LogInformation("Starting job search...");
await _linkedInService.SearchConnectionAsync();
}
}
}

=== FILE: F:\LiveNetwork\Commands\obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs ===

using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

=== FILE: F:\LiveNetwork\Commands\obj\Debug\net8.0\Commands.AssemblyInfo.cs ===

using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("Commands")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+a6b4d3e6fdf732a0e433e9886ef84950f11282b3")]
[assembly: System.Reflection.AssemblyProductAttribute("Commands")]
[assembly: System.Reflection.AssemblyTitleAttribute("Commands")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

=== FILE: F:\LiveNetwork\Commands\obj\Debug\net8.0\Commands.GlobalUsings.g.cs ===

global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;

=== FILE: F:\LiveNetwork\Commands\obj\Release\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs ===

using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]

=== FILE: F:\LiveNetwork\Commands\obj\Release\net8.0\Commands.AssemblyInfo.cs ===

using System;
using System.Reflection;
[assembly: System.Reflection.AssemblyCompanyAttribute("Commands")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Release")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+1f7b61cc657b6b85a6c4b54e1aee2477c28bbe28")]
[assembly: System.Reflection.AssemblyProductAttribute("Commands")]
[assembly: System.Reflection.AssemblyTitleAttribute("Commands")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

=== FILE: F:\LiveNetwork\Commands\obj\Release\net8.0\Commands.GlobalUsings.g.cs ===

global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;